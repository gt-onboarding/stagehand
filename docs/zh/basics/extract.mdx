---
title: 提取
description: 从网页提取结构化数据
---

## 什么是 `extract()`？ {#what-is-extract}

```typescript
page.extract("extract the name of the repository");
```

`extract` 用于从网页提取结构化数据。你可以使用 [Zod](https://github.com/colinhacks/zod)（TypeScript）或 [Pydantic](https://github.com/pydantic/pydantic)（Python）定义模式。如果不想定义模式，也可以仅凭[自然语言提示](#extract-with-just-a-prompt)调用 `extract`，或[不传任何参数](#extract-with-no-parameters)进行调用。

## 为什么使用 `extract()`？ {#why-use-extract}

<CardGroup cols={2}>
  <Card title="结构化" icon="brackets-curly" href="#list-of-objects-extraction">
    将杂乱的网页数据转化为符合模式的干净对象。
  </Card>

  <Card title="稳健" icon="dumbbell" href="#extract-with-context">
    构建在网站变化时仍能正常工作的稳健提取。
  </Card>
</CardGroup>

<Note>
  在 TypeScript 中，提取使用 Zod 模式定义。

  在 Python 中，提取使用 Pydantic 模型定义。
</Note>

## 使用 `extract()` {#using-extract}

### 单对象提取 {#single-object-extraction}

以下展示了针对单个对象的 `extract` 调用示例：

<CodeGroup>
  ```typescript TypeScript
  const item = await page.extract({
    instruction: "extract the price of the item",
    schema: z.object({
      price: z.number(),
    }),
  });
  ```

  ```python Python
  class Extraction(BaseModel):
      price: float

  item = await page.extract(
      "extract the price of the item",
      schema=Extraction
  )
  ```
</CodeGroup>

输出模式如下：

```Example
{ price: number }
```

### 对象列表提取 {#list-of-objects-extraction}

以下展示了针对对象列表的 `extract` 调用示例：

<CodeGroup>
  ```typescript TypeScript
  const apartments = await page.extract({
    instruction:
      "Extract ALL the apartment listings and their details, including address, price, and square feet.",
    schema: z.object({
      list_of_apartments: z.array(
        z.object({
          address: z.string(),
          price: z.string(),
          square_feet: z.string(),
        }),
      ),
    })
  })

  console.log("the apartment list is: ", apartments);
  ```

  ```python Python
  class Apartment(BaseModel):
      address: str
      price: str
      square_feet: str

  class Apartments(BaseModel):
      list_of_apartments: list[Apartment]

  apartments = await page.extract(
      "Extract ALL the apartment listings and their details as a list, including address, price, and square feet for each apartment",
      schema=Apartments
  )

  print("the apartment list is: ", apartments)
  ```
</CodeGroup>

输出模式如下：

```Example
list_of_apartments: [
    {
      address: "street address here",
      price: "$1234.00",
      square_feet: "700"
    },
    {
        address: "another address here",
        price: "1010.00",
        square_feet: "500"
    },
    ...
]
```

### 仅提示提取 {#prompt-only-extraction}

你可以仅使用自然语言提示调用 `extract`：

<CodeGroup>
  ```typescript TypeScript
  const result = await page.extract("extract the name of the repository");
  ```

  ```python Python
  result = await page.extract("extract the name of the repository")
  ```
</CodeGroup>

当仅以提示调用 `extract` 时，输出模式如下：

```Example
{ extraction: string }
```

### 无参数提取 {#extract-with-no-parameters}

以下展示了如何在无参数情况下调用 `extract`：

<CodeGroup>
  ```typescript TypeScript
  const pageText = await page.extract();
  ```

  ```python Python
  page_text = await page.extract()
  ```
</CodeGroup>

输出模式：

```Example
{ page_text: string }
```

在无参数情况下调用 `extract` 将返回根 DOM 的分层树表示。该过程不会经过 LLM。示例如下：

```
Accessibility Tree:
[0-2] RootWebArea: What is Stagehand? - 🤘 Stagehand
  [0-37] scrollable
    [0-118] body
      [0-241] scrollable
        [0-242] div
          [0-244] link: 🤘 Stagehand home page light logo
            [0-245] span
              [0-246] StaticText: 🤘 Stagehand
              [0-247] StaticText: home page
```

## 最佳实践 {#best-practices}

### 结合上下文进行提取 {#extract-with-context}

你可以为模式提供额外的上下文，帮助模型更准确地提取数据。

<CodeGroup>
  ```typescript TypeScript
  const apartments = await page.extract({
   instruction:
     "Extract ALL the apartment listings and their details, including address, price, and square feet.",
   schema: z.object({
     list_of_apartments: z.array(
       z.object({
         address: z.string().describe("the address of the apartment"),
         price: z.string().describe("the price of the apartment"),
         square_feet: z.string().describe("the square footage of the apartment"),
       }),
     ),
   })
  })
  ```

  ```python Python
  class Apartment(BaseModel):
      address: str = Field(..., description="the address of the apartment")
      price: str = Field(..., description="the price of the apartment")
      square_feet: str = Field(..., description="the square footage of the apartment")

  class Apartments(BaseModel):
      list_of_apartments: list[Apartment]

  apartments = await page.extract(
      "Extract ALL the apartment listings and their details as a list. For each apartment, include: the address of the apartment, the price of the apartment, and the square footage of the apartment",
      schema=Apartments
  )
  ```
</CodeGroup>

### 链接提取 {#link-extraction}

<Note>
  要提取链接或 URL，在 Stagehand 的 TypeScript 版本中，你需要将相关字段定义为 `z.string().url()`。
  在 Python 中，你需要将其定义为 `HttpUrl`。
</Note>

下面展示了一个用于提取链接或 URL 的 `extract` 调用示例。同样适用于图片链接。

<CodeGroup>
  ```typescript TypeScript
  const extraction = await page.extract({
    instruction: "extract the link to the 'contact us' page",
    schema: z.object({
      link: z.string().url(), // 注意这里使用 z.string().url()
    }),
  });

  console.log("the link to the contact us page is: ", extraction.link);
  ```

  ```python Python
  class Extraction(BaseModel):
      link: HttpUrl # 注意这里使用 HttpUrl

  extraction = await page.extract(
      "extract the link to the 'contact us' page", 
      schema=Extraction
  )

  print("the link to the contact us page is: ", extraction.link)
  ```
</CodeGroup>

<Tip>
  在 Stagehand 内部，链接提取通过让 LLM 选择一个 ID 实现。Stagehand 会在 ID -> URL 的映射中查找该 ID。记录 LLM 追踪日志时，你会看到的是 ID。实际的 URL 将包含在最终的 `ExtractResult` 中。
</Tip>

## 故障排查 {#troubleshooting}

<AccordionGroup>
  <Accordion title="结果为空或不完整">
    **问题**: `extract()` 返回空或不完整的数据

    **解决方案**:

    - **检查指令清晰度**: 确保指令足够具体，并准确描述要提取的数据
    - **验证数据是否存在**: 先使用 `page.observe()` 确认页面上确实存在该数据
    - **等待动态内容加载**: 若页面以动态方式加载内容，提取前先调用 `page.act("wait for the content to load")`

    **解决方案：在提取前等待内容加载**

    <CodeGroup>
      ```typescript TypeScript
      // 在提取前等待内容加载
      await page.act("wait for the product listings to load");
      const products = await page.extract({
        instruction: "extract all product names and prices",
        schema: z.object({
          products: z.array(z.object({
            name: z.string(),
            price: z.string()
          }))
        })
      });
      ```

      ```python Python
      # 在提取前等待内容加载
      await page.act("wait for the product listings to load")
      products = await page.extract(
          "extract all product names and prices",
          schema=ProductList
      )
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="Schema 验证错误">
    **问题**: 出现 Schema 验证错误或类型不匹配

    **解决方案**:

    - **使用可选字段**: 若数据可能并非总是存在，使用 `z.optional()`（TypeScript）或 `Optional[type]`（Python）
    - **使用更灵活的类型**: 对可能包含货币符号的价格，考虑使用 `z.string()` 而非 `z.number()`
    - **添加描述信息**: 使用 `.describe()`（TypeScript）或 `Field(description="...")`（Python）帮助模型理解字段要求

    **解决方案：更灵活的 Schema**

    <CodeGroup>
      ```typescript TypeScript
      const schema = z.object({
        price: z.string().describe("price including currency symbol, e.g., '$19.99'"),
        availability: z.string().optional().describe("stock status if available"),
        rating: z.number().optional()
      });
      ```

      ```python Python
      class FlexibleProduct(BaseModel):
          price: str = Field(description="price including currency symbol, e.g., '$19.99'")
          availability: Optional[str] = Field(default=None, description="stock status if available")
          rating: Optional[float] = None
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="结果不一致">
    **问题**: 不同运行之间的提取结果存在差异

    **解决方案**:

    - **让指令更具体**: 不要写“extract prices”，而应写“extract the numerical price value for each item”
    - **在 Schema 描述中提供上下文**: 为字段添加描述以引导模型
    - **结合 observe 使用**: 先用 `page.observe()` 理解页面结构

    **解决方案：先用 observe 验证**

    <CodeGroup>
      ```typescript TypeScript
      // 先进行 observe 以理解页面结构
      const elements = await page.observe("find all product listings");
      console.log("Found elements:", elements.map(e => e.description));

      // 然后进行更有针对性的提取
      const products = await page.extract({
        instruction: "extract name and price from each product listing shown on the page",
        schema: z.object({
          products: z.array(z.object({
            name: z.string().describe("the product title or name"),
            price: z.string().describe("the price as displayed, including currency")
          }))
        })
      });
      ```

      ```python Python
      # 先进行 observe 以理解页面结构
      elements = await page.observe("find all product listings")
      print("Found elements:", [e.description for e in elements])

      # 然后进行更有针对性的提取
      products = await page.extract(
          "extract name and price from each product listing shown on the page",
          schema=ProductSchema
      )
      ```
    </CodeGroup>
  </Accordion>

  <Accordion title="性能问题">
    **问题**：提取速度慢或发生超时

    **解决方案**：

    - **缩小范围**：将数据拆分为多次、较小的提取，而不是一次性提取全部
    - **使用针对性指令**：明确需要关注的页面区域
    - **考虑分页**：对于大型数据集，逐页提取
    - **增加超时时间**：在复杂提取中使用 `timeoutMs` 参数

    **解决方案：拆分大型提取任务**

    <CodeGroup>
      ```typescript TypeScript
      // Instead of extracting everything at once
      const allData = [];
      const pageNumbers = [1, 2, 3, 4, 5];

      for (const pageNum of pageNumbers) {
        await page.act(`navigate to page ${pageNum}`);
        
        const pageData = await page.extract({
          instruction: "extract product data from the current page only",
          schema: ProductPageSchema,
          timeoutMs: 60000 // 60 second timeout
        });
        
        allData.push(...pageData.products);
      }
      ```

      ```python Python
      # Instead of extracting everything at once
      all_data = []
      page_numbers = [1, 2, 3, 4, 5]

      for page_num in page_numbers:
          await page.act(f"navigate to page {page_num}")
          
          page_data = await page.extract(
              "extract product data from the current page only",
              schema=ProductPageSchema,
              timeout_ms=60000  # 60 second timeout
          )
          
          all_data.extend(page_data.products)
      ```
    </CodeGroup>
  </Accordion>
</AccordionGroup>

## 后续步骤 {#next-steps}

<CardGroup cols={2}>
  <Card title="Act" icon="play" href="/zh/basics/act">
    使用 observe() 的结果高效执行操作
  </Card>

  <Card title="Observe" icon="magnifying-glass" href="/zh/basics/observe">
    通过 observe() 分析页面
  </Card>
</CardGroup>