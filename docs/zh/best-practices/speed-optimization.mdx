---
title: 速度优化
sidebarTitle: 速度优化
description: 优化 Stagehand 性能，以实现更快的自动化与更低的延迟
---

Stagehand 的性能取决于多种因素：DOM 处理速度、LLM 推理时间、浏览器操作以及网络延迟。本文提供行之有效的策略，帮助最大化自动化速度。

## 快速性能优化 {#quick-performance-wins}

### 1. 先用 observe 做规划 {#1-plan-ahead-with-observe}

使用一次 `observe()` 调用来规划多个动作，然后高效执行：

<CodeGroup>
  ```typescript TypeScript
  // 避免顺序操作导致多次 LLM 调用
  await page.act("Fill name field");        // LLM 调用 #1
  await page.act("Fill email field");       // LLM 调用 #2
  await page.act("Select country dropdown"); // LLM 调用 #3

  // 用一次 observe 规划所有表单字段 —— 仅一次 LLM 调用
  const formFields = await page.observe("Find all form fields to fill");

  // 在不进行 LLM 推理的情况下执行所有动作
  for (const field of formFields) {
    await page.act(field); // 无 LLM 调用！
  }

  ```

  ```python Python
  import asyncio

  # 避免顺序操作导致多次 LLM 调用
  await page.act("Fill name field")        # LLM 调用 #1
  await page.act("Fill email field")       # LLM 调用 #2  
  await page.act("Select country dropdown") # LLM 调用 #3

  # 用一次 observe 规划所有表单字段 —— 仅一次 LLM 调用
  form_fields = await page.observe("Find all form fields to fill")

  # 在不进行 LLM 推理的情况下执行所有动作
  for field in form_fields:
      await page.act(field) # 无 LLM 调用！
  ```
</CodeGroup>

<Note>
  **性能提示**：直接对 `observe` 的结果执行可完全避免 LLM 推理。该方式通常比直接调用 `act()` 快 2–3 倍，是多步工作流的推荐模式。
</Note>

<Card title="缓存指南" icon="database" href="/zh/best-practices/caching">
  学习高级缓存模式与缓存失效策略
</Card>

### 2. 优化 DOM 处理 {#2-optimize-dom-processing}

在 Stagehand 处理页面前先降低 DOM 复杂度：

<CodeGroup>
  ```typescript TypeScript
  // 移除会拖慢处理的重型元素
  await page.evaluate(() => {
    // 移除视频等元素
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // 隐藏复杂动画
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      (el as HTMLElement).style.animation = 'none';
    });
  });

  // 然后执行 Stagehand 操作
  await page.act("Click the submit button");
  ```

  ```python Python
  # 移除会拖慢处理的重型元素
  await page.evaluate("""
  () => {
    // 移除视频等元素
    document.querySelectorAll('video, iframe').forEach(el => el.remove());
    
    // 隐藏复杂动画
    document.querySelectorAll('[style*="animation"]').forEach(el => {
      el.style.animation = 'none';
    });
  }
  """)

  # 然后执行 Stagehand 操作
  await page.act("Click the submit button")
  ```
</CodeGroup>

### 3. 设置合适的超时 {#3-set-appropriate-timeouts}

简单操作使用更短超时，复杂页面加载使用更长超时：

<CodeGroup>
  ```typescript TypeScript
  // 简单动作 —— 缩短动作超时
  await page.act({ 
    instruction: "Click the login button",
    actTimeout: 5000  // 默认 30000ms，简单点击可缩短
  });

  // 复杂页面加载 —— 优化导航
  await page.goto("https://heavy-spa.com", {
    waitUntil: "domcontentloaded", // 无需等待所有资源加载
    timeout: 15000 // 低于默认 30s
  });
  ```

  ```python Python
  # 简单动作 —— 缩短动作超时
  await page.act("Click button", act_timeout=5000)

  # 复杂页面加载 —— 优化导航
  await page.goto("https://heavy-spa.com", 
      wait_until="domcontentloaded",
      timeout=15000
  )
  ```
</CodeGroup>

## 高级性能策略 {#advanced-performance-strategies}

### 智能模型选择 {#smart-model-selection}

对简单任务使用更快的模型，仅在必要时使用高阶模型：

<CodeGroup>
  ```typescript TypeScript
  class SpeedOptimizedStagehand {
    private fastModel: Stagehand;
    private premiumModel: Stagehand;

    async smartAct(page: Page, prompt: string, complexity: 'simple' | 'complex') {
      const model = complexity === 'simple' ? this.fastModel : this.premiumModel;
      return await model.page.act(prompt);
    }
  }

  // 对简单的点击/表单使用快速模型
  await stagehand.smartAct(page, "Click submit", 'simple');

  // 对复杂推理使用高阶模型
  await stagehand.smartAct(page, "Find the cheapest flight option", 'complex');
  ```

  ```python Python
  class SpeedOptimizedStagehand:
      def __init__(self):
          self.fast_model = Stagehand(model_name="fast-model")
          self.premium_model = Stagehand(model_name="premium-model")
      
      async def smart_act(self, page, prompt: str, complexity: str):
          model = self.fast_model if complexity == 'simple' else self.premium_model
          return await model.page.act(prompt)

  # 对简单的点击/表单使用快速模型
  await stagehand.smart_act(page, "Click submit", 'simple')

  # 对复杂推理使用高阶模型  
  await stagehand.smart_act(page, "Find the cheapest flight option", 'complex')
  ```
</CodeGroup>

<Card title="模型配置" icon="brain" href="/zh/configuration/models">
  比较模型的性能与成本
</Card>

### 页面加载优化 {#page-load-optimization}

在页面加载时跳过不必要的资源：

<CodeGroup>
  ```typescript TypeScript
  // 全局阻止大体量资源
  await context.route('**/*', (route) => {
    const resourceType = route.request().resourceType();
    if (['image', 'font', 'media'].includes(resourceType)) {
      route.abort();
    } else {
      route.continue();
    }
  });

  // 使用更快的导航方式
  await page.goto(url, { 
    waitUntil: 'domcontentloaded',  // 不等待图片/字体
    timeout: 10000 
  });
  ```

  ```python Python
  # 全局阻止大体量资源
  async def handle_route(route):
      resource_type = route.request.resource_type
      if resource_type in ['image', 'font', 'media']:
          await route.abort()
      else:
          await route.continue_()

  await context.route('**/*', handle_route)

  # 使用更快的导航方式
  await page.goto(url, 
      wait_until='domcontentloaded',  # 不等待图片/字体
      timeout=10000
  )
  ```
</CodeGroup>

<Card title="成本优化" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
  在速度与成本之间寻求平衡
</Card>

## 性能监控与基准测试 {#performance-monitoring-and-benchmarking}

跟踪性能指标并量化优化效果：

### 性能跟踪 {#performance-tracking}

<CodeGroup>
  ```typescript TypeScript
  class PerformanceTracker {
    private speedMetrics: Map<string, number[]> = new Map();

    async timedAct(page: Page, prompt: string): Promise<ActResult> {
      const start = Date.now();
      const result = await page.act(prompt);
      const duration = Date.now() - start;
      
      if (!this.speedMetrics.has(prompt)) {
        this.speedMetrics.set(prompt, []);
      }
      this.speedMetrics.get(prompt)!.push(duration);
      
      console.log(`Action "${prompt}" took ${duration}ms`);
      return result;
    }

    getAverageTime(prompt: string): number {
      const times = this.speedMetrics.get(prompt) || [];
      return times.reduce((a, b) => a + b, 0) / times.length;
    }
  }
  ```

  ```python Python
  import time
  from collections import defaultdict

  class PerformanceTracker:
      def __init__(self):
          self.speed_metrics = defaultdict(list)
      
      async def timed_act(self, page, prompt: str):
          start = time.time()
          result = await page.act(prompt)
          duration = (time.time() - start) * 1000  # 转换为毫秒
          
          self.speed_metrics[prompt].append(duration)
          print(f'Action "{prompt}" took {duration:.0f}ms')
          return result
      
      def get_average_time(self, prompt: str) -> float:
          times = self.speed_metrics[prompt]
          return sum(times) / len(times) if times else 0
  ```
</CodeGroup>

示例输出：

```
Action "Fill form" took 1000ms
Action "Click submit" took 2000ms
Action "Confirm submission" took 5000ms
```

### 优化前后对比基准 {#before-vs-after-benchmarking}

<CodeGroup>
  ```typescript TypeScript
  // 优化前
  console.time("workflow");
  await page.act("Fill form");
  await page.act("Click submit");
  await page.act("Confirm submission");
  console.timeEnd("workflow"); // 8000ms

  // 使用 observe 规划后的优化
  console.time("workflow-optimized");
  const workflowActions = await page.observe("Find form, submit, and confirm elements");

  // 依次执行以避免冲突
  for (const action of workflowActions) {
    await page.act(action);
  }
  console.timeEnd("workflow-optimized"); // 500ms
  ```

  ```python Python
  import time

  # 优化前
  start = time.time()
  await page.act("Fill form")
  await page.act("Click submit") 
  await page.act("Confirm submission")
  print(f"Workflow took {(time.time() - start) * 1000:.0f}ms")  # 8000ms

  # 使用 observe 规划后的优化
  start = time.time()
  workflow_actions = await page.observe("Find form, submit, and confirm elements")

  # 依次执行以避免冲突
  for action in workflow_actions:
      await page.act(action)
  print(f"Optimized workflow took {(time.time() - start) * 1000:.0f}ms")  # 500ms
  ```
</CodeGroup>

示例输出：

```
Workflow took 8000ms
Optimized workflow took 500ms
```

<CardGroup cols={1}>
  <Card title="可观测性与指标" icon="chart-line" href="/zh/configuration/observability">
    配置全面的性能监控
  </Card>
</CardGroup>

## 相关资源 {#related-resources}

<CardGroup cols={2}>
  <Card title="缓存策略" icon="database" href="/zh/best-practices/caching">
    高级缓存策略，最大化性能
  </Card>

  <Card title="成本优化" icon="dollar-sign" href="/zh/best-practices/cost-optimization">
    在速度提升与成本之间取得平衡
  </Card>

  <Card title="浏览器配置" icon="window-maximize" href="/zh/configuration/browser">
    优化 Browserbase 设置以提升速度
  </Card>

  <Card title="模型选择" icon="brain" href="/zh/configuration/models">
    在速度与准确性之间选择合适的模型
  </Card>
</CardGroup>