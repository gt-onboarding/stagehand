---
title: "构建网页浏览代理"
description: "使用 Stagehand 构建可自主控制浏览器的 AI 代理"
---

import { Excalidraw } from '/snippets/excalidraw.mdx';

Stagehand 为 AI 代理提供了强大的工具，能够完全自主地控制浏览器。请观看下方演示：Stagehand 代理如何自主访问指定网址、在页面上执行操作，并提取结构化数据来回答问题。
使用 Stagehand 构建代理有多种方式。我们来看看其中的几种。

![Agent](/media/stagehand-agent.gif)

## Stagehand MCP {#stagehand-mcp}

上面的示例展示了一个使用 Stagehand 控制浏览器的 Claude 代理。撰写本文时，[多模态工具调用](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling#multi-modal-tool-results) 仅在 Claude 3.5/3.7 Sonnet 中受支持。
这意味着 Claude 足够智能，能在需要时请求浏览器截图，并据此判断下一步应采取哪些操作。

<CardGroup>
  <Card title="Browserbase MCP" href="https://github.com/browserbase/mcp-server-browserbase/" icon="hand-horns">
    使用由 Stagehand 驱动的 Browserbase MCP 控制浏览器
  </Card>
</CardGroup>

更有意思的是，代理能够将对浏览器状态的推理与页面操作解耦！
Claude 负责对浏览器状态进行推理，而 Stagehand 则可使用 GPT-4o-mini 或 Computer Use 模型在页面上执行动作。
Stagehand 甚至能够智能选择何时使用 GPT-4o-mini、何时使用 Computer Use 模型，例如在检测到 iframe 时。

<Excalidraw className="w-full aspect-video" url="https://link.excalidraw.com/readonly/GWQWmWUBqMBEAamlWsIM?darkMode=true" />

我们发现，将 Claude 作为“Trajectory”代理，在合适的时机调用 Stagehand 工具，效果非常出色！
虽然 MCP 尚处于早期阶段，但我们对其发展充满期待。

## Stagehand + Computer Use 模型 {#stagehand-computer-use-models}

只需一行代码，Stagehand 即可调用 OpenAI 与 Anthropic 提供的强大 Computer Use API。

<CodeGroup>
  ```typescript TypeScript
  await page.goto("https://github.com/browserbase/stagehand");

  // 只用一行代码创建一个 Computer Use 代理！
  const agent = stagehand.agent({
  	provider: "openai",
  	model: "computer-use-preview"
  });

  // 使用代理来执行任务
  const result = await agent.execute("Extract the top contributor's username");
  console.log(result);
  ```

  ```python Python
  await page.goto("https://github.com/browserbase/stagehand-python")

  # 只用一行代码创建一个 Computer Use 代理！
  agent = stagehand.agent(
      model="computer-use-preview"
  )

  # 使用代理来执行任务
  result = await agent.execute("Extract the top contributor's username")
  print(result)
  ```
</CodeGroup>

<CardGroup>
  <Card title="Stagehand + Computer Use 文档" href="/zh/best-practices/computer-use" icon="scroll">
    查看我们的文档，了解如何在 Stagehand 中使用 Computer Use 模型。
  </Card>

  <Card title="CUA 浏览器演示" href="https://cua.browserbase.com/" icon="brain-circuit">
    查看由 OpenAI 的 Computer Using Agent（CUA）模型控制的 Browserbase 浏览器在线演示。
  </Card>
</CardGroup>

## 顺序工具调用（Open Operator） {#sequential-tool-calling-open-operator}

2025 年 1 月，Browserbase 发布了 [Open Operator](https://operator.browserbase.com)。
Open Operator 能够基于浏览器状态进行推理，并据此采取动作来完成更复杂的任务，例如“帮我点一份披萨”。
它通过按顺序调用 Stagehand 工具来运作：

1. 如果没有 URL，则访问默认 URL。
2. 检查浏览器状态，并让 LLM 推理下一步该做什么。
3. 使用 `page.act()` 执行 LLM 建议的动作。
4. 重复以上步骤

<Excalidraw className="w-full" url="https://link.excalidraw.com/readonly/dKh5sB1gEM1EjVqRCGKn" />

将 `stagehand.agent` 融入你的浏览器自动化，只需添加一行代码：

<Note>
  Python 目前通过 Computer Use Agent（CUA）模型支持 `stagehand.agent`。默认实现即将上线。
</Note>

<CodeGroup>
  ```typescript TypeScript
  await stagehand.page.goto("https://github.com/browserbase/stagehand");

  // Open Operator 将使用 Stagehand 配置中的默认 LLM
  const operator = stagehand.agent();
  const { message, actions } = await operator.execute(
  	"Extract the top contributor's username"
  );

  console.log(message);
  ```
</CodeGroup>

### 回放代理的动作 {#replay-the-agents-actions}

你可以像使用常规 Stagehand 代理那样原样回放代理的动作。你甚至可以自动缓存这些动作，以在重复运行时避免不必要的 LLM 调用。

我们使用下面的 `replay` 函数把这些动作保存到一个 Stagehand 脚本文件中，该文件会复现代理执行过的相同步骤，并内置动作缓存。

<Accordion title="utils.ts">
  ```typescript
  import { AgentAction, AgentResult } from "@browserbasehq/stagehand";
  import { exec } from "child_process";
  import fs from "fs/promises";

  export async function replay(result: AgentResult) {
    const history = result.actions;
    const replay = history
      .map((action: AgentAction) => {
        switch (action.type) {
          case "act":
            if (!action.playwrightArguments) {
              throw new Error("No playwright arguments provided");
            }
            return `await page.act(${JSON.stringify(
              action.playwrightArguments
            )})`;
          case "extract":
            return `await page.extract("${action.parameters}")`;
          case "goto":
            return `await page.goto("${action.parameters}")`;
          case "wait":
            return `await page.waitForTimeout(${parseInt(
              action.parameters as string
            )})`;
          case "navback":
            return `await page.goBack()`;
          case "refresh":
            return `await page.reload()`;
          case "close":
            return `await stagehand.close()`;
          default:
            return `await stagehand.oops()`;
        }
      })
      .join("\n");

    console.log("Replay:");
    const boilerplate = `
  import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

  export async function main(stagehand: Stagehand) {
      const page = stagehand.page
  	${replay}
  }
    `;
    await fs.writeFile("replay.ts", boilerplate);

    // 使用 prettier 格式化回放文件
    await new Promise((resolve, reject) => {
      exec(
        "npx prettier --write replay.ts",
        (error: any, stdout: any, stderr: any) => {
          if (error) {
            console.error(\`Error formatting replay.ts: \${error}\`);
            reject(error);
            return;
          }
          resolve(stdout);
        }
      );
    });
  }
  ```
</Accordion>

以下是针对类似 “Get me the stock price of NVDA” 这类指令的回放输出：

```typescript {14-22} replay.ts
import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // 具有 act、extract 和 observe 方法的 Playwright Page
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand 实例
}) {
  await page.goto("https://www.google.com");

  // Replay 默认先使用 Playwright，以避免不必要的 LLM 调用！
  // 如果 Playwright 动作失败，Stagehand AI 将接管并进行自愈
  await page.act({
    description: "用户输入查询的搜索框（组合框）。",
    method: "fill",
    arguments: ["NVDA stock price"],
    selector:
      "xpath=/html/body[1]/div[1]/div[3]/form[1]/div[1]/div[1]/div[1]/div[1]/div[2]/textarea[1]",
  });
  await page.extract(
    "搜索联想中显示的 NVDA 股价",
  );
  await stagehand.close();
}
```