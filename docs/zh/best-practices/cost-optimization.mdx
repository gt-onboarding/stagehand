---
title: 成本优化  
sidebarTitle: 成本优化
description: 在保持自动化性能的同时将成本降至最低
---

在 Stagehand 中的成本优化需要同时权衡 LLM 推理成本与浏览器基础设施成本。本文提供可操作的实用策略，帮助你降低自动化成本。

<div id="quick-wins">
  ## 快速获益
</div>

从这些简单的优化入手，可降低成本：

<div id="1-use-the-right-model-for-the-job">
  ### 1. 为任务选择合适的模型
</div>

我们不建议为简单任务使用更大、更高端的模型。查看我们的[评估结果](https://stagehand.dev/evals)，比较不同任务类型下的模型性能与成本。

<CardGroup cols={2}>
  <Card title="模型选择指南" icon="brain" href="/zh/configuration/models">
    按预算与准确性需求选择合适的 LLM
  </Card>

  <Card title="评估结果" icon="chart-line" href="https://www.stagehand.dev/evals">
    了解不同模型在不同任务上的表现
  </Card>
</CardGroup>

<div id="2-implement-smart-caching">
  ### 2. 实施智能缓存
</div>

缓存成功的动作以避免重复的 LLM 调用。在我们的[缓存指南](/zh/best-practices/caching)中了解基础用法：

<CodeGroup>
  ```typescript TypeScript
  // Cache successful actions
  const [action] = await page.observe("Click the sign in button");
  await setCache("sign_in_button", action);

  // Reuse cached action (no LLM cost)
  const cachedAction = await getCache("sign_in_button");
  if (cachedAction) {
    await page.act(cachedAction);
  } else {
    await page.act(action);
  }
  ```

  ```python Python
  # Cache successful actions
  actions = await page.observe("Click the sign in button")
  action = actions[0]
  await set_cache("sign_in_button", action)

  # Reuse cached action (no LLM cost)
  cached_action = await get_cache("sign_in_button")
  if cached_action:
      await page.act(cached_action)
  else:
      await page.act(action)
  ```
</CodeGroup>

<CardGroup cols={1}>
  <Card title="缓存指南" icon="database" href="/zh/best-practices/caching">
    通过智能动作缓存与 observe 模式降低成本
  </Card>
</CardGroup>

<div id="3-optimize-browser-sessions">
  ### 3. 优化浏览器会话
</div>

尽可能复用会话，并设置合适的超时时间。详情见[浏览器配置](/zh/configuration/browser)：

<CodeGroup>
  ```typescript TypeScript
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    browserbaseSessionCreateParams: {
      timeout: 1800, // 30 minutes instead of default 1 hour
      keepAlive: true, // Keep session alive between tasks
    }
  });
  ```

  ```python Python
  stagehand = Stagehand(
      env="BROWSERBASE",
      browserbase_session_create_params={
          "timeout": 1800,  # 30 minutes instead of default 1 hour
          "keep_alive": True,  # Keep session alive between tasks
      }
  )
  ```
</CodeGroup>

<CardGroup cols={1}>
  <Card title="Browserbase 成本优化" icon="window-maximize" href="https://docs.browserbase.com/guides/cost-optimization">
    优化 Browserbase 基础设施成本与会话管理
  </Card>
</CardGroup>

<div id="advanced-strategies">
  ## 高级策略
</div>

<div id="intelligent-model-switching">
  ### 智能模型切换
</div>

针对简单任务自动切换至更低成本的模型：

<CodeGroup>
  ```typescript TypeScript
  // 根据任务复杂度按从低到高的成本选择模型
  // 参见 stagehand.dev/evals 获取性能与成本对比
  async function smartAct(page: Page, prompt: string) {
    const models = ["cheaper-model", "premium-model"];
    
    for (const model of models) {
      try {
        const stagehand = new Stagehand({ modelName: model });
        await stagehand.init();
        const [action] = await stagehand.page.observe(prompt);
        await stagehand.page.act(action);
        return;
      } catch (error) {
        console.log(`回退到 ${model}...`);
      }
    }
  }
  ```

  ```python Python
  # 根据任务复杂度按从低到高的成本选择模型
  # 参见 stagehand.dev/evals 获取性能与成本对比
  async def smart_act(page, prompt: str):
      models = ["cheaper-model", "premium-model"]
      
      for model in models:
          try:
              stagehand = Stagehand(model_name=model)
              await stagehand.init()
              actions = await stagehand.page.observe(prompt)
              action = actions[0]
              await stagehand.page.act(action)
              return
          except Exception:
              print(f"回退到 {model}...")
  ```
</CodeGroup>

<div id="session-pooling">
  ### 会话池化
</div>

在多个任务之间复用浏览器会话：

<CodeGroup>
  ```typescript TypeScript
  class SessionManager {
    private sessions = new Map<string, Stagehand>();
    
    async getSession(taskType: string): Promise<Stagehand> {
      if (this.sessions.has(taskType)) {
        return this.sessions.get(taskType)!;
      }
      
      const stagehand = new Stagehand({ env: "BROWSERBASE" });
      await stagehand.init();
      this.sessions.set(taskType, stagehand);
      return stagehand;
    }
  }
  ```

  ```python Python
  class SessionManager:
      def __init__(self):
          self.sessions = {}
      
      async def get_session(self, task_type: str):
          if task_type in self.sessions:
              return self.sessions[task_type]
          
          stagehand = Stagehand(env="BROWSERBASE")
          await stagehand.init()
          self.sessions[task_type] = stagehand
          return stagehand
  ```
</CodeGroup>

<div id="cost-monitoring">
  ## 成本监控
</div>

跟踪支出以发现优化机会。有关详细指标，请参阅我们的[可观测性指南](/zh/configuration/observability)：

<CodeGroup>
  ```typescript TypeScript
  // 监控 token 使用量
  const metrics = stagehand.metrics;
  console.log(`Total tokens: ${metrics.totalPromptTokens + metrics.totalCompletionTokens}`);
  console.log(`Estimated cost: $${(metrics.totalPromptTokens + metrics.totalCompletionTokens) * 0.00001}`);
  ```

  ```python Python
  # 监控 token 使用量
  metrics = stagehand.metrics
  total_tokens = metrics['total_prompt_tokens'] + metrics['total_completion_tokens']
  print(f"Total tokens: {total_tokens}")
  print(f"Estimated cost: ${total_tokens * 0.00001:.4f}")
  ```
</CodeGroup>

<CardGroup cols={1}>
  <Card title="可观测性与指标" icon="chart-line" href="/zh/configuration/observability">
    实时监控使用模式并跟踪成本
  </Card>
</CardGroup>

<div id="budget-controls">
  ## 预算控制
</div>

设置支出上限，避免意外费用：

<CodeGroup>
  ```typescript TypeScript
  class BudgetGuard {
    private dailySpend = 0;
    private maxDailyBudget: number;
    
    constructor(maxDailyBudget: number = 25) {
      this.maxDailyBudget = maxDailyBudget;
    }
    
    checkBudget(estimatedCost: number): void {
      if (this.dailySpend + estimatedCost > this.maxDailyBudget) {
        throw new Error(`已超出每日预算：$${this.maxDailyBudget}`);
      }
      this.dailySpend += estimatedCost;
    }
  }
  ```

  ```python Python
  class BudgetGuard:
      def __init__(self, max_daily_budget: float = 25.0):
          self.daily_spend = 0
          self.max_daily_budget = max_daily_budget
      
      def check_budget(self, estimated_cost: float) -> None:
          if self.daily_spend + estimated_cost > self.max_daily_budget:
              raise Exception(f"已超出每日预算：${self.max_daily_budget}")
          self.daily_spend += estimated_cost
  ```
</CodeGroup>

<div id="related-resources">
  ## 相关资源
</div>

<CardGroup cols={2}>
  <Card title="模型选择指南" icon="brain" href="/zh/configuration/models">
    按预算与准确性需求选择合适的 LLM
  </Card>

  <Card title="缓存策略" icon="database" href="/zh/best-practices/caching">
    通过智能动作缓存与 observe 模式降低成本
  </Card>

  <Card title="可观测性与指标" icon="chart-line" href="/zh/configuration/observability">
    实时监控使用模式并追踪成本
  </Card>

  <Card title="浏览器配置" icon="window-maximize" href="/zh/configuration/browser">
    优化 Browserbase 基础设施成本与会话管理
  </Card>
</CardGroup>