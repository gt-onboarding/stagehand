---
title: AI 规则
description: 使用 AI 更快、更好地编写 Stagehand 代码。
---

你大概率会用 AI 来写代码，而这件事有正确与错误的方式。本页汇集了一套规则、配置和可复制粘贴的片段，帮助你的 AI 代理/助手尽可能快速地编写高性能的 Stagehand 代码。

## 快速开始 {#quickstart}

<CardGroup cols={2}>
  <Card title="添加 MCP 服务器" icon="screwdriver-wrench">
    在你的 MCP 客户端中配置 Browserbase（Stagehand）、Context7、DeepWiki 和 Stagehand 文档。
  </Card>

  <Card title="固定编辑器规则" icon="memo">
    添加 `cursorrules` 和 `claude.md`，让 AI 代理/助手始终按 Stagehand 模式输出。
  </Card>
</CardGroup>

## 使用 MCP 服务器 {#using-mcp-servers}

MCP（Model Context Protocol）服务器充当中间层，将 AI 系统连接到外部数据源与工具。这些服务器使你的编码助手能够访问实时信息、执行任务并检索结构化数据，从而提升代码生成的准确性。

以下这些**MCP 服务器**可为 Stagehand 文档及相关资源提供专项访问：

<Accordion title="Upstash 的 Context7" icon="database">
  提供对文档与代码库上下文的语义搜索。Context7 使 AI 助手能够从你的项目历史中查找相关的代码模式、示例和实现细节。它持续把握你的开发工作流的上下文，并可从以往工作中呈现相关解决方案。

  **安装：**

  ```json
  {
    "mcpServers": {
      "context7": {
        "command": "npx",
        "args": ["-y", "@upstash/context7-mcp"]
      }
    }
  }
  ```
</Accordion>

<Accordion title="Cognition 的 DeepWiki" icon="book-open">
  提供对 GitHub 仓库与文档的深度索引。DeepWiki 使 AI 代理能够从整个 Stagehand 生态中理解项目架构、API 参考与最佳实践。它提供关于仓库结构、代码关系和开发模式的全面知识。

  **安装：**

  ```json
  {
    "mcpServers": {
      "deepwiki": {
        "url": "https://mcp.deepwiki.com/mcp"
      }
    }
  }
  ```
</Accordion>

<Accordion title="Mintlify 的 Stagehand Docs" icon="mintbit">
  直接访问官方 Stagehand 文档。该 MCP 服务器为 AI 助手提供最新的 API 参考、配置选项与使用示例，助你生成更准确的代码。Mintlify 会从官方文档自动生成此服务器，确保你的 AI 助手始终掌握最新信息。

  **用法：**

  ```json
  {
    "mcpServers": {
      "stagehand-docs": {
        "url": "https://docs.stagehand.dev/mcp"
      }
    }
  }
  ```
</Accordion>

**MCP 服务器如何提升你的开发：**

- **实时文档访问**：AI 助手可查询最新的 Stagehand 文档、示例与最佳实践
- **上下文感知的代码生成**：服务器会基于你的具体用例提供相关代码模式与配置
- **降低集成开销**：标准化协议免去为每个文档源进行自定义集成的需要
- **提升准确性**：AI 代理获得结构化、最新的信息，而非依赖可能过时的训练数据

<Tip>
  **提示技巧：**
  明确要求你的编码代理/助手使用这些 MCP 服务器从文档中获取相关信息，以便具备更充分的上下文并知道如何编写合规的 Stagehand 代码。

  例如：**“Use the stagehand-docs MCP to fetch the act/observe guidelines, then generate code that follows them. Prefer cached observe results.”**
</Tip>

## 编辑器规则文件（复制粘贴） {#editor-rule-files-copypaste}

将以下内容放入 `.cursorrules`、`windsurfrules`、`claude.md`，或任何代理规则框架中：

<Accordion title="TypeScript">
  ````md
  # Stagehand 项目

  这是一个使用 [Stagehand](https://github.com/browserbase/stagehand) 的项目。Stagehand 通过在 Page 类中加入由 AI 驱动的 `act`、`extract` 和 `observe` 方法来增强 Playwright。

  `Stagehand` 是一个类，提供以下配置与浏览器自动化能力：
  - `stagehand.page`：StagehandPage 对象（扩展自 Playwright 的 Page）
  - `stagehand.context`：StagehandContext 对象（扩展自 Playwright 的 BrowserContext）
  - `stagehand.agent()`：创建用于自主多步工作流的 AI 代理
  - `stagehand.init()`：初始化浏览器会话
  - `stagehand.close()`：清理资源

  `Page` 在 Playwright 的 Page 基础上扩展了由 AI 驱动的方法：
  - `act()`：使用自然语言对网页元素执行操作
  - `extract()`：使用 schema 从页面提取结构化数据
  - `observe()`：在执行前规划动作并获取选择器

  `Agent` 提供自主的 Computer Use Agent 能力：
  - `execute()`：根据自然语言指令执行复杂的多步任务

  `Context` 扩展了 Playwright 的 BrowserContext 类，用于管理浏览器会话。

  请遵循以下规则为该项目编写代码。

  - 要规划诸如“点击登录按钮”之类的指令，使用 Stagehand 的 `observe` 获取要执行的动作。

  ```typescript
  const results = await page.observe("Click the sign in button");
  ```

  你也可以传入以下参数：

  ```typescript
  await page.observe({
    instruction: "the instruction to execute",
    returnAction: true 
  });
  ```

  - `observe` 的结果是一个由 `ObserveResult` 对象组成的数组，可直接作为 `act` 的参数使用，如下所示：
    ```typescript
    const results = await page.observe({
      instruction: "the instruction to execute",
      returnAction: true, // 返回要执行的动作
    });

    await page.act(results[0]);
    ```
    
  - 当编写需要从页面提取数据的代码时，使用 Stagehand 的 `extract`。默认显式传入以下参数：

  ```typescript
  const { someValue } = await page.extract({
    instruction: "the instruction to execute",
    schema: z.object({
      someValue: z.string(),
    }), // 要提取的 schema
  });
  ```

  ## 初始化

  ```typescript
  import { Stagehand, Page, BrowserContext } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "BROWSERBASE"
  });

  await stagehand.init();

  const page = stagehand.page; // 带有 act、extract、observe 方法的 Playwright Page

  const context = stagehand.context; // Playwright BrowserContext
  ```
  ### 配置选项
  ```typescript
  const StagehandConfig = {
    env: "BROWSERBASE" | "LOCAL", // 运行环境
    apiKey: process.env.BROWSERBASE_API_KEY, // Browserbase API 密钥
    projectId: process.env.BROWSERBASE_PROJECT_ID, // Browserbase 项目 ID
    debugDom: true, // 启用 DOM 调试功能
    headless: false, // 以无头模式运行浏览器
    domSettleTimeoutMs: 30_000, // 在执行前等待 DOM 稳定的超时时间
    enableCaching: true, // 启用动作缓存
    modelName: "gpt-4o", // 使用的 AI 模型
    modelClientOptions: {
      apiKey: process.env.OPENAI_API_KEY, // OpenAI API 密钥
    },
  };
  ```
  ## Act

  你可以直接用字符串指令进行操作：

  ```typescript
  await page.act("点击“登录”按钮");
  ```

  使用变量进行动态表单填写：

  ```typescript
  await page.act({
    action: `输入以下信息：
      姓名：%name%
      邮箱：%email%
      电话：%phone%`,
    variables: {
      name: "John Doe",
      email: "john@example.com", 
      phone: "+1-555-0123"
    }
  });
  ```

  **最佳实践：**
  - 缓存 `observe` 的结果以避免意外的 DOM 变更
  - 使动作保持原子且具体（例如，“点击‘登录’按钮”，而不是“登录网站”）
  - 使用变量替换进行动态数据填写

  Act 的 `action` 应尽可能原子且具体，例如“点击‘登录’按钮”或“在搜索框中输入‘hello’”
  避免包含多个步骤的动作，例如“帮我点披萨”或“给 Paul 发邮件让他给我回电”

  ## 提取

  ### 简单字符串提取

  ```typescript
  const signInButtonText = await page.extract("提取“登录”按钮的文本");
  ```

  ### 使用 Schema 的结构化提取（推荐）

  请始终使用 Zod Schema 来提取结构化数据：

  ```typescript
  import { z } from "zod";

  const data = await page.extract({
    instruction: "提取“登录”按钮的文本",
    schema: z.object({
      text: z.string(),
    }),
  });
  ```

  ### 数组提取

  要提取多个条目，请将数组包裹在单个对象中：

  ```typescript
  const data = await page.extract({
    instruction: "提取所有按钮内的文本",
    schema: z.object({
      buttons: z.array(z.string()),
    })
  });
  ```

  ### 复杂对象提取

  用于更复杂的数据结构：

  ```typescript
  const productData = await page.extract({
    instruction: "从此页面提取产品信息",
    schema: z.object({
      title: z.string(),
      price: z.number(),
      description: z.string(),
      features: z.array(z.string()),
      availability: z.boolean(),
    }),
  });
  ```

  ### Schema 校验

  ```typescript
  import { validateZodSchema } from "./utils.js";
  import { z } from "zod";

  const schema = z.object({ name: z.string() });
  const isValid = validateZodSchema(schema, { name: "John" }); // true
  ```

  ## 代理系统

  Stagehand 提供用于自主网页浏览的代理系统，采用 Computer Use Agent（CUA）。代理可依据自然语言指令执行多步工作流。

  ### 创建代理

  ```typescript
  // 基础代理（默认）
  const agent = stagehand.agent();

  // OpenAI 代理
  const agent = stagehand.agent({
    provider: "openai",
    model: "computer-use-preview",
    instructions: "你是一名能够使用网页浏览器的有用助手。",
    options: { 
      apiKey: process.env.OPENAI_API_KEY 
    }
  });

  // Anthropic 代理
  const agent = stagehand.agent({
    provider: "anthropic", 
    model: "claude-sonnet-4-20250514",
    instructions: "你是一名能够使用网页浏览器的有用助手。",
    options: { 
      apiKey: process.env.ANTHROPIC_API_KEY 
    }
  });
  ```
  ### 代理执行
  ```typescript
  // 简单任务
  const result = await agent.execute("提取此网页的标题");

  // 复杂的多步任务
  const result = await agent.execute({
    instruction: "使用模拟数据申请第一个工程师职位",
    maxSteps: 20,
    autoScreenshot: true
  });
  ```

  ### 最佳实践
  - 指令要具体：`"填写联系表单，姓名为 'John Doe'，并提交"`
  - 将复杂任务拆解为更小的步骤
  - 使用 try/catch 进行错误处理
  - 结合：用代理负责导航，配合传统方法进行精准的数据提取

  ```typescript
  // 推荐：具体的指令
  await agent.execute("进入产品页面并按『Electronics』进行筛选");

  // 避免：模糊的指令  
  await agent.execute("在这个页面上随便做点事");
  ```

  ## 项目结构最佳实践

  - 将配置存放在 `stagehand.config.ts` 中
  - 使用环境变量管理 API 密钥（参见 `.env.example`）
  - 将主要自动化逻辑实现为接受 `{ page, context, stagehand }` 的函数
  - 使用 TypeScript，并从 `@browserbasehq/stagehand` 正确导入
  ````
</Accordion>

<Accordion title="Python">
  ````md
  # Stagehand Python 项目

  这是一个使用 [Stagehand Python](https://github.com/browserbase/stagehand-python) 的项目，它通过 `act`、`extract` 和 `observe` 方法提供 AI 增强的浏览器自动化。

  `Stagehand` 是一个类，提供以下配置与浏览器自动化能力：
  - `stagehand.page`: 一个 StagehandPage 对象（扩展自 Playwright 的 Page）
  - `stagehand.context`: 一个 StagehandContext 对象（扩展自 Playwright 的 BrowserContext）
  - `stagehand.agent()`: 创建用于执行多步自主工作流的 AI 代理
  - `stagehand.init()`: 初始化浏览器会话
  - `stagehand.close()`: 释放资源

  `Page` 在 Playwright 的 Page 类之上扩展了 AI 驱动的方法：
  - `act()`: 使用自然语言对网页元素执行操作
  - `extract()`: 基于模式从页面提取结构化数据
  - `observe()`: 在执行前规划操作并获取选择器

  `Agent` 提供自主的 Computer Use Agent 能力：
  - `execute()`: 使用自然语言指令执行复杂的多步任务

  请遵循以下规则为本项目编写代码。

  - 要规划诸如“点击登录按钮”这类指令，请使用 Stagehand `observe` 获取要执行的动作。

  ```python
  results = await page.observe("Click the sign in button")
  ```

  你也可以传入以下参数：

  ```python
  await page.observe(
      instruction="the instruction to execute",
      draw_overlay=True  # 在被观察的元素上显示可视化高亮层
  )
  ```

  - `observe` 的结果是 `ObserveResult` 对象列表，可直接作为 `act` 的参数使用，如下所示：
    ```python
    results = await page.observe("Click the sign in button")
    await page.act(results[0])
    ```
  - 当需要从页面提取数据时，请使用 Stagehand `extract`。使用 Pydantic 模型来定义模式：

  ```python
  from pydantic import BaseModel

  class ExtractedData(BaseModel):
      some_value: str

  result = await page.extract(
      instruction="要执行的指令",
      schema=ExtractedData
  )
  ```

  ## 初始化

  ```python
  from stagehand import Stagehand, StagehandConfig
  import asyncio
  import os
  from dotenv import load_dotenv

  load_dotenv()

  async def main():
      config = StagehandConfig(
          env="BROWSERBASE",  # or "LOCAL"
          api_key=os.getenv("BROWSERBASE_API_KEY"),
          project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
          model_name="google/gemini-2.5-flash-preview-05-20",
          model_api_key=os.getenv("MODEL_API_KEY"),
      )
      
      # 建议：作为异步上下文管理器使用
      async with Stagehand(config) as stagehand:
          page = stagehand.page
          # 在此编写你的自动化代码
          
      # 可选：手动初始化
      stagehand = Stagehand(config)
      await stagehand.init()
      page = stagehand.page
      # 在此编写你的自动化代码
      await stagehand.close()

  if __name__ == "__main__":
      asyncio.run(main())
  ```

  ### 配置项

  `StagehandConfig` 的关键配置项：

  ```python
  config = StagehandConfig(
      env="BROWSERBASE",  # or "LOCAL"
      api_key=os.getenv("BROWSERBASE_API_KEY"),
      project_id=os.getenv("BROWSERBASE_PROJECT_ID"),
      model_name="google/gemini-2.5-flash-preview-05-20",
      model_api_key=os.getenv("MODEL_API_KEY"),
      verbose=1,  # 0=最少，1=适中，2=详细
      dom_settle_timeout_ms=30000,
      self_heal=True,  # 启用自我修复功能
  )
  ```

  ## Act

  你可以直接使用字符串指令执行操作：

  ```python
  await page.act("点击“登录”按钮")
  ```

  使用变量进行动态表单填写：

  ```python
  await page.act(
      "输入以下信息：姓名：John Doe，邮箱：john@example.com"
  )
  ```

  **最佳实践：**
  - 缓存 `observe` 的结果，以避免意外的 DOM 变更
  - 让操作保持原子且具体（例如，用“点击‘登录’按钮”，而不是“登录网站”）
  - 使用具体且有描述性的指令

  Act 的 `action` 应尽可能原子且具体，例如：“点击‘登录’按钮”或“在搜索框中输入‘hello’。”
  避免包含多个步骤的操作，例如：“帮我点披萨”或“给 Paul 发邮件，让他给我回个电话。”

  ## 提取

  ### 简单字符串提取
  ```python
  sign_in_button_text = await page.extract("提取“登录”按钮的文本")
  ```

  ### 使用模式的结构化提取（推荐）
  对于结构化数据提取，始终使用 Pydantic 模型：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class ButtonData(BaseModel):
      text: str = Field(..., description="按钮文本内容")

  data = await page.extract(
      instruction="提取“登录”按钮的文本",
      schema=ButtonData
  )
  ```

  ### 数组提取
  对于数组，使用 List 类型：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class ButtonsData(BaseModel):
      buttons: List[str] = Field(..., description="按钮文本列表")

  data = await page.extract(
      instruction="提取所有按钮的文本内容",
      schema=ButtonsData
  )
  ```

  ### 复杂对象提取
  对于更复杂的数据结构：

  ```python
  from pydantic import BaseModel, Field
  from typing import List

  class Company(BaseModel):
      name: str = Field(..., description="公司名称")
      description: str = Field(..., description="公司简要介绍")

  class Companies(BaseModel):
      companies: List[Company] = Field(..., description="公司列表")

  companies_data = await page.extract(
      "提取 5 家公司的名称和简介",
      schema=Companies
  )
  ```

  ## 代理系统

  Stagehand 提供用于借助 Computer Use Agent（CUA）进行自主网页浏览的代理系统。

  ### 创建代理

  ```python
  # 基础代理（使用默认模型）
  agent = stagehand.agent()

  # OpenAI 代理
  agent = stagehand.agent(
      model="computer-use-preview",
      instructions="你是一名乐于助人的网页导航助理。",
      options={"apiKey": os.getenv("OPENAI_API_KEY")}
  )

  # Anthropic 代理
  agent = stagehand.agent(
      model="claude-sonnet-4-20250514",
      instructions="你是一名乐于助人的网页导航助理。"
      options={"apiKey": os.getenv("ANTHROPIC_API_KEY")}
  )
  ```

  ### 代理运行

  ```python
  # 简单任务
  result = await agent.execute("玩一局 2048")

  # 带选项的复杂多步任务
  result = await agent.execute(
      instruction="使用模拟数据申请第一个工程师岗位",
      max_steps=20,
      auto_screenshot=True,
      wait_between_actions=1000  # 毫秒
  )
  ```

  **最佳实践：**
  - 指令要具体：`"填写联系表单，姓名为 'John Doe'，并提交"`
  - 将复杂任务拆解为更小的步骤
  - 使用 try/except 代码块进行错误处理
  - 导航使用代理，精确数据提取采用传统方法，二者结合

  ```python
  # 推荐：具体且明确的指令
  await agent.execute("前往产品页，并筛选为「电子产品」")

  # 避免：指令含糊不清
  await agent.execute("在此页面上随便做点事")
  ```

  ## 项目结构最佳实践

  - 将配置存放在环境变量或配置文件中
  - 全程一致地使用 async/await 模式
  - 将主要的自动化逻辑实现为异步函数
  - 使用异步上下文管理器进行资源管理
  - 使用类型注解和 Pydantic 模型进行数据验证
  - 使用 try/except 代码块合理处理异常
  ````
</Accordion>

## 安全注意事项 {#security-notes}

- 不要在文档或规则文件中硬编码机密信息；请在 MCP 配置中使用环境变量。
- 避免可能导致意外跳转的宽泛操作；优先使用 `observe`。

## 资源/参考 {#resourcesreferences}

- Context7 MCP（Upstash）
  - https://github.com/upstash/context7
- DeepWiki MCP
  - https://mcp.deepwiki.com/
- Stagehand 文档 MCP（Mintlify）
  - https://docs.stagehand.dev/mcp
