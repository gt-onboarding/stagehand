---
title: 可观测性
sidebarTitle: 可观测性
description: 通过会话可见性与分析跟踪 Stagehand 自动化
---

Stagehand 提供强大的可观测性功能，帮助您监控、衡量性能并分析浏览器自动化工作流。内容涵盖 Browserbase 与本地环境中的会话监控、资源使用与运行洞察。

<div id="browserbase-session-monitoring">
  ## Browserbase 会话监控
</div>

在 Browserbase 上运行时，您可通过 Browserbase API 与仪表板获得完整的云端监控与会话管理能力。

<div style={{ textAlign: "center" }}>
  <img src="/media/observability.gif" alt="Browserbase 会话可观测性" width="400" />
</div>

<div id="live-session-visibility">
  ### 实时会话可见性
</div>

Browserbase 为您的自动化会话提供实时可见性：

**会话仪表板功能**

- 实时浏览器屏幕录制与回放
- 带详细时序的网络请求监控
- JavaScript 控制台日志与错误跟踪
- CPU 与内存使用指标
- 会话状态与时长跟踪

**会话管理与 API 访问**

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";
  import { Browserbase } from "@browserbasehq/sdk";

  const browserbase = new Browserbase({
    apiKey: process.env.BROWSERBASE_API_KEY,
  });

  const stagehand = new Stagehand({
    env: "BROWSERBASE"
  });

  await stagehand.init();

  const sessionInfo = await browserbase.sessions.retrieve(stagehand.sessionId);

  console.log("Session status:", sessionInfo.status);
  console.log("Session region:", sessionInfo.region);
  console.log("CPU usage:", sessionInfo.avgCpuUsage);
  console.log("Memory usage:", sessionInfo.memoryUsage);
  console.log("Proxy bytes:", sessionInfo.proxyBytes);
  ```

  ```python Python
  import os
  from stagehand import Stagehand
  from browserbase import Browserbase

  browserbase = Browserbase(
    api_key=os.getenv("BROWSERBASE_API_KEY"),
  )

  stagehand = Stagehand(
      env="BROWSERBASE",
  )

  await stagehand.init()

  session_info = browserbase.sessions.retrieve(stagehand.session_id)

  print(f"Session status: {session_info['status']}")
  print(f"Session region: {session_info['region']}")
  print(f"CPU usage: {session_info['avgCpuUsage']}")
  print(f"Memory usage: {session_info['memoryUsage']}")
  print(f"Proxy bytes: {session_info['proxyBytes']}")
  ```
</CodeGroup>

<div id="session-analytics-insights">
  ### 会话分析与洞察
</div>

<CardGroup>
  <Card title="Real-Time Monitoring" icon="chart-line">
    监控实时会话状态、资源使用与地理分布。基于实时洞察进行扩缩容并管理并发会话。
  </Card>

  <Card title="Session Recordings" icon="video">
    回看完整会话录制，支持逐帧播放。以可视化方式分析网络请求并调试浏览器交互。
  </Card>

  <Card title="API Management" icon="code">
    以编程方式访问会话数据，自动化生命周期管理，并通过我们的 API 集成到监控系统。
  </Card>

  <Card title="Usage Monitoring" icon="chart-bar">
    跟踪资源消耗、会话时长与 API 使用情况。获取覆盖整个自动化流程的成本与利用率的详细拆分。
  </Card>
</CardGroup>

<div id="session-monitoring-filtering">
  ### 会话监控与筛选
</div>

按状态与元数据查询并监控会话：

<CodeGroup>
  ```typescript TypeScript
  import { Browserbase } from "@browserbasehq/sdk";

  const browserbase = new Browserbase({
    apiKey: process.env.BROWSERBASE_API_KEY,
  });

  // 通过筛选列出会话
  async function getFilteredSessions() {
    const sessions = await browserbase.sessions.list({
      status: 'RUNNING'
    });
    
    return sessions.map(session => ({
      id: session.id,
      status: session.status, // RUNNING, COMPLETED, ERROR, TIMED_OUT
      startedAt: session.startedAt,
      endedAt: session.endedAt,
      region: session.region,
      avgCpuUsage: session.avgCpuUsage,
      memoryUsage: session.memoryUsage,
      proxyBytes: session.proxyBytes,
      userMetadata: session.userMetadata
    }));
  }

  // 按元数据查询会话
  async function querySessionsByMetadata(query: string) {
    const sessions = await browserbase.sessions.list({
      q: query
    });
    
    return sessions;
  }
  ```

  ```python Python
  import os
  from browserbase import Browserbase

  browserbase = Browserbase(
      api_key=os.getenv("BROWSERBASE_API_KEY"),
  )

  def get_filtered_sessions():
      sessions = browserbase.sessions.list(status="RUNNING")
      
      return [{
          'id': session['id'],
          'status': session['status'],  # RUNNING, COMPLETED, ERROR, TIMED_OUT
          'started_at': session['startedAt'],
          'ended_at': session['endedAt'],
          'region': session['region'],
          'avg_cpu_usage': session['avgCpuUsage'],
          'memory_usage': session['memoryUsage'],
          'proxy_bytes': session['proxyBytes'],
          'user_metadata': session['userMetadata']
      } for session in sessions]

  def query_sessions_by_metadata(query):
      sessions = browserbase.sessions.list(q=query)
      
      return sessions
  ```
</CodeGroup>

<div id="local-environment-monitoring">
  ## 本地环境监控
</div>

在本地开发场景下，Stagehand 可在你的机器上直接提供性能监控与资源跟踪能力。

<div id="performance-tracking">
  ### 性能跟踪
</div>

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1, // 在无调试噪声的情况下监控性能
  });

  // 跟踪本地自动化指标
  const startTime = Date.now();
  const initialMetrics = stagehand.metrics;

  // ... 执行自动化任务

  const finalMetrics = stagehand.metrics;
  const executionTime = Date.now() - startTime;

  console.log('本地性能摘要:', {
    executionTime: `${executionTime}ms`,
    totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
    averageResponseTime: finalMetrics.totalInferenceTimeMs / 3, // 假设进行 3 次操作
    tokensPerSecond: (finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / (executionTime / 1000)
  });
  ```

  ```python Python
  from stagehand import Stagehand
  import time

  stagehand = Stagehand(
      env="LOCAL",
      verbose=1,  # 在无调试噪声的情况下监控性能
  )

  # 跟踪本地自动化指标
  start_time = time.time()
  initial_metrics = stagehand.metrics

  # ... 执行自动化任务

  final_metrics = stagehand.metrics
  execution_time = (time.time() - start_time) * 1000  # 转换为毫秒

  print('本地性能摘要:', {
      'execution_time': f"{execution_time:.0f}ms",
      'total_tokens': final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens'],
      'average_response_time': final_metrics['total_inference_time_ms'] / 3,  # 假设进行 3 次操作
      'tokens_per_second': (final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens']) / (execution_time / 1000)
  })
  ```
</CodeGroup>

<div id="resource-usage-monitoring">
  ## 资源使用监控
</div>

在本地运行时，请监控系统资源占用与浏览器性能：

<CodeGroup>
  ```typescript TypeScript
  import { Stagehand } from "@browserbasehq/stagehand";
  import * as os from 'os';
  import { performance } from 'perf_hooks';

  class LocalResourceMonitor {
    private cpuUsage: number[] = [];
    private memoryUsage: number[] = [];
    
    startMonitoring() {
      const interval = setInterval(() => {
        // 跟踪系统资源
        const memUsage = process.memoryUsage();
        this.memoryUsage.push(memUsage.heapUsed / 1024 / 1024); // MB
        
        // 跟踪 CPU（简化）
        const loadAvg = os.loadavg()[0];
        this.cpuUsage.push(loadAvg);
      }, 1000);
      
      return interval;
    }
    
    getResourceSummary() {
      return {
        avgMemoryUsage: this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length,
        peakMemoryUsage: Math.max(...this.memoryUsage),
        avgCpuLoad: this.cpuUsage.reduce((a, b) => a + b, 0) / this.cpuUsage.length,
        totalDataPoints: this.cpuUsage.length
      };
    }
  }

  const monitor = new LocalResourceMonitor();
  const interval = monitor.startMonitoring();

  const stagehand = new Stagehand({ env: "LOCAL" });

  // ... 运行自动化任务

  clearInterval(interval);
  console.log('Resource Usage:', monitor.getResourceSummary());
  ```

  ```python Python
  import psutil
  import time
  from typing import List
  from stagehand import Stagehand

  class LocalResourceMonitor:
      def __init__(self):
          self.cpu_usage: List[float] = []
          self.memory_usage: List[float] = []
          self.monitoring = False
      
      def start_monitoring(self):
          self.monitoring = True
          import threading
          
          def monitor_resources():
            while self.monitoring:
                # 跟踪 CPU 与内存占用
                cpu_percent = psutil.cpu_percent(interval=1)
                memory_info = psutil.virtual_memory()
                
                self.cpu_usage.append(cpu_percent)
                self.memory_usage.append(memory_info.percent)
                
                time.sleep(1)
          
          thread = threading.Thread(target=monitor_resources)
          thread.daemon = True
          thread.start()
          return thread
      
      def stop_monitoring(self):
          self.monitoring = False
      
      def get_resource_summary(self):
          if not self.cpu_usage or not self.memory_usage:
              return {'error': '未收集到监控数据'}
          
          return {
              'avg_cpu_usage': sum(self.cpu_usage) / len(self.cpu_usage),
              'peak_cpu_usage': max(self.cpu_usage),
              'avg_memory_usage': sum(self.memory_usage) / len(self.memory_usage),
              'peak_memory_usage': max(self.memory_usage),
              'total_data_points': len(self.cpu_usage)
          }

  monitor = LocalResourceMonitor()
  monitor.start_monitoring()

  stagehand = Stagehand(env="LOCAL")

  # ... 运行自动化任务

  monitor.stop_monitoring()
  print('Resource Usage:', monitor.get_resource_summary())
  ```
</CodeGroup>

<Card title="LLM 使用情况" icon="chart-line" href="/zh/configuration/evals">
  监控 Token 用量、成本与速度；为关键故障设置自动告警；在不同环境中实施成本跟踪；使用会话分析优化自动化工作流。
</Card>

<div id="real-time-metrics-monitoring">
  ## 实时指标与监控
</div>

<div id="basic-usage-tracking">
  ### 基本用量跟踪
</div>

使用 `stagehand.metrics` 实时监控自动化的资源使用情况：

<CodeGroup>
  ```typescript TypeScript
  // 获取当前指标
  console.log(stagehand.metrics);

  // 在自动化过程中监控
  const startTime = Date.now();
  const initialMetrics = stagehand.metrics;

  // ... 执行自动化任务

  const finalMetrics = stagehand.metrics;
  const executionTime = Date.now() - startTime;

  console.log('Automation Summary:', {
    totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
    totalCost: calculateCost(finalMetrics),
    executionTime,
    efficiency: (finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / executionTime
  });
  ```

  ```python Python
  # 获取当前指标
  print(stagehand.metrics)

  # 在自动化过程中监控
  import time
  start_time = time.time()
  initial_metrics = stagehand.metrics

  # ... 执行自动化任务

  final_metrics = stagehand.metrics
  execution_time = (time.time() - start_time) * 1000  # 转换为毫秒

  print('Automation Summary:', {
      'total_tokens': final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens'],
      'total_cost': calculate_cost(final_metrics),
      'execution_time': execution_time,
      'efficiency': (final_metrics['total_prompt_tokens'] + final_metrics['total_completion_tokens']) / execution_time
  })
  ```
</CodeGroup>

<div id="understanding-metrics-data">
  ### 了解指标数据
</div>

metrics 对象按 Stagehand 操作提供详细拆分：

<CodeGroup>
  ```typescript TypeScript
  {
    actPromptTokens: 4011,
    actCompletionTokens: 51,
    actInferenceTimeMs: 1688,

    extractPromptTokens: 4200,
    extractCompletionTokens: 243,
    extractInferenceTimeMs: 4297,

    observePromptTokens: 347,
    observeCompletionTokens: 43,
    observeInferenceTimeMs: 903,

    totalPromptTokens: 8558,
    totalCompletionTokens: 337,
    totalInferenceTimeMs: 6888
  }
  ```

  ```python Python
  {
    "act_prompt_tokens": 4011,
    "act_completion_tokens": 51,
    "act_inference_time_ms": 1688,

    "extract_prompt_tokens": 4200,
    "extract_completion_tokens": 243,
    "extract_inference_time_ms": 4297,

    "observe_prompt_tokens": 347,
    "observe_completion_tokens": 43,
    "observe_inference_time_ms": 903,

    "total_prompt_tokens": 8558,
    "total_completion_tokens": 337,
    "total_inference_time_ms": 6888
  }
  ```
</CodeGroup>

<div id="log-inference-to-file">
  ### 将推理日志写入文件
</div>

也可以将 `logInferenceToFile` 设为 `true`，把推理过程记录到文件。这将在项目根目录创建名为 `inference_summary` 的目录。

<CodeGroup>
  ```typescript TypeScript
  const stagehand = new Stagehand({
    logInferenceToFile: true,    
  });
  ```

  ```python Python
  stagehand = Stagehand(
      log_inference_to_file=True,             
  )
  ```
</CodeGroup>

`inference_summary` 目录提供更细粒度的分析数据：

```
inference_summary/
├── act_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── act_summary.json
├── extract_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── extract_summary.json
├── observe_summary/
│   ├── {timestamp}.json
│   ├── {timestamp}.json
│   └── ...
│   └── observe_summary.json
```

<div id="log-file-structure">
  ### 日志文件结构
</div>

每个操作都会生成用于分析的详细日志：

```typescript
{
  "act_summary": [
    {
      "act_inference_type": "act",
      "timestamp": "20250329_080446068",
      "LLM_input_file": "20250329_080446068_act_call.txt",
      "LLM_output_file": "20250329_080447019_act_response.txt",
      "prompt_tokens": 3451,
      "completion_tokens": 45,
      "inference_time_ms": 951
    },
    ...
  ],
}
```

<div id="best-practices">
  ## 最佳实践
</div>

<AccordionGroup>
  <Accordion title="Production Monitoring">
    - 跟踪会话成功率与失败模式
    - 监控资源使用与扩容需求
    - 为关键故障设置自动告警
    - 在不同环境中进行成本跟踪
    - 使用会话分析优化自动化工作流
  </Accordion>

  <Accordion title="Performance Optimization">
    - 比较 Browserbase 与本地的执行时间
    - 跨模型监控 token 使用量与推理成本
    - 跟踪不同地域的性能差异
    - 识别自动化工作流中的瓶颈
    - 优化成本效益与速度
  </Accordion>

  <Accordion title="Operational Insights">
    - 跟踪会话在各地区的分布
    - 监控并发会话上限与扩容情况
    - 分析失败模式与常见错误场景
    - 使用会话录制进行根因分析
    - 通过自定义元数据对工作流进行分类
  </Accordion>

  <Accordion title="Integration & Alerting">
    - 将会话 API 集成到监控仪表板
    - 为会话失败设置自动通知
    - 跟踪 SLA 合规性与性能基准
    - 监控资源成本与使用模式
    - 使用分析数据进行容量规划与优化
  </Accordion>
</AccordionGroup>

有关详细的日志与调试能力，请参见[Logging](/zh/configuration/logging)。